?start: translation_unit

// Primary expressions
?primary_expression: IDENTIFIER
                   | CONSTANT
                   | STRING_LITERAL
                   | "(" expression ")"

// Postfix expressions
?postfix_expression: primary_expression
                   | postfix_expression "[" expression "]"
                   | postfix_expression "(" ")"
                   | postfix_expression "(" argument_expression_list ")"
                   | postfix_expression "." IDENTIFIER
                   | postfix_expression PTR_OP IDENTIFIER
                   | postfix_expression INC_OP
                   | postfix_expression DEC_OP

argument_expression_list: assignment_expression ("," assignment_expression)*

// Unary expressions
?unary_expression: postfix_expression
                 | INC_OP unary_expression
                 | DEC_OP unary_expression
                 | unary_operator cast_expression
                 | SIZEOF unary_expression
                 | SIZEOF "(" type_name ")"

unary_operator: "&" | "*" | "+" | "-" | "~" | "!"

// Cast expression
?cast_expression: unary_expression
                | "(" type_name ")" cast_expression

// Binary expressions (with precedence)
?multiplicative_expression: cast_expression
                          | multiplicative_expression "*" cast_expression
                          | multiplicative_expression "/" cast_expression
                          | multiplicative_expression "%" cast_expression

?additive_expression: multiplicative_expression
                    | additive_expression "+" multiplicative_expression
                    | additive_expression "-" multiplicative_expression

?shift_expression: additive_expression
                 | shift_expression LEFT_OP additive_expression
                 | shift_expression RIGHT_OP additive_expression

?relational_expression: shift_expression
                      | relational_expression "<" shift_expression
                      | relational_expression ">" shift_expression
                      | relational_expression LE_OP shift_expression
                      | relational_expression GE_OP shift_expression

?equality_expression: relational_expression
                    | equality_expression EQ_OP relational_expression
                    | equality_expression NE_OP relational_expression

?and_expression: equality_expression
               | and_expression "&" equality_expression

?exclusive_or_expression: and_expression
                        | exclusive_or_expression "^" and_expression

?inclusive_or_expression: exclusive_or_expression
                        | inclusive_or_expression "|" exclusive_or_expression

?logical_and_expression: inclusive_or_expression
                       | logical_and_expression AND_OP inclusive_or_expression

?logical_or_expression: logical_and_expression
                      | logical_or_expression OR_OP logical_and_expression

?conditional_expression: logical_or_expression
                       | logical_or_expression "?" expression ":" conditional_expression

// Assignment
?assignment_expression: conditional_expression
                      | unary_expression assignment_operator assignment_expression

assignment_operator: "=" | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN
                   | SUB_ASSIGN | LEFT_ASSIGN | RIGHT_ASSIGN | AND_ASSIGN
                   | XOR_ASSIGN | OR_ASSIGN

?expression: assignment_expression
           | expression "," assignment_expression

constant_expression: conditional_expression

// Declarations
declaration: declaration_specifiers ";"
           | declaration_specifiers init_declarator_list ";"

declaration_specifiers: storage_class_specifier+
                      | type_specifier+
                      | type_qualifier+
                      | (storage_class_specifier | type_specifier | type_qualifier)+

init_declarator_list: init_declarator ("," init_declarator)*

init_declarator: declarator
               | declarator "=" initializer

storage_class_specifier: TYPEDEF | EXTERN | STATIC | AUTO | REGISTER

type_specifier: VOID | CHAR | SHORT | INT | LONG | FLOAT | DOUBLE
              | SIGNED | UNSIGNED
              | struct_or_union_specifier
              | enum_specifier
              | TYPE_NAME

// Struct/Union
struct_or_union_specifier: struct_or_union IDENTIFIER "{" struct_declaration_list "}"
                         | struct_or_union "{" struct_declaration_list "}"
                         | struct_or_union IDENTIFIER

struct_or_union: STRUCT | UNION

struct_declaration_list: struct_declaration+

struct_declaration: specifier_qualifier_list struct_declarator_list ";"

specifier_qualifier_list: (type_specifier | type_qualifier)+

struct_declarator_list: struct_declarator ("," struct_declarator)*

struct_declarator: declarator
                 | ":" constant_expression
                 | declarator ":" constant_expression

// Enum
enum_specifier: ENUM "{" enumerator_list "}"
              | ENUM IDENTIFIER "{" enumerator_list "}"
              | ENUM IDENTIFIER

enumerator_list: enumerator ("," enumerator)*

enumerator: IDENTIFIER
          | IDENTIFIER "=" constant_expression

type_qualifier: CONST | VOLATILE

// Declarators
declarator: pointer? direct_declarator

direct_declarator: IDENTIFIER
                 | "(" declarator ")"
                 | direct_declarator "[" constant_expression "]"
                 | direct_declarator "[" "]"
                 | direct_declarator "(" parameter_type_list ")"
                 | direct_declarator "(" identifier_list ")"
                 | direct_declarator "(" ")"

pointer: "*" type_qualifier_list? pointer?

type_qualifier_list: type_qualifier+

parameter_type_list: parameter_list ("," ELLIPSIS)?

parameter_list: parameter_declaration ("," parameter_declaration)*

parameter_declaration: declaration_specifiers declarator?
                     | declaration_specifiers abstract_declarator?

identifier_list: IDENTIFIER ("," IDENTIFIER)*

type_name: specifier_qualifier_list abstract_declarator?

abstract_declarator: pointer
                   | direct_abstract_declarator
                   | pointer direct_abstract_declarator

direct_abstract_declarator: "(" abstract_declarator ")"
                          | "[" "]"
                          | "[" constant_expression "]"
                          | direct_abstract_declarator "[" "]"
                          | direct_abstract_declarator "[" constant_expression "]"
                          | "(" ")"
                          | "(" parameter_type_list ")"
                          | direct_abstract_declarator "(" ")"
                          | direct_abstract_declarator "(" parameter_type_list ")"

// Initializers
initializer: assignment_expression
           | "{" initializer_list "}"
           | "{" initializer_list "," "}"

initializer_list: initializer ("," initializer)*

// Statements
?statement: labeled_statement
          | compound_statement
          | expression_statement
          | selection_statement
          | iteration_statement
          | jump_statement

labeled_statement: IDENTIFIER ":" statement
                 | CASE constant_expression ":" statement
                 | DEFAULT ":" statement

compound_statement: "{" "}"
                  | "{" statement_list "}"
                  | "{" declaration_list "}"
                  | "{" declaration_list statement_list "}"

declaration_list: declaration+

statement_list: statement+

expression_statement: ";"
                    | expression ";"

selection_statement: IF "(" expression ")" statement
                   | IF "(" expression ")" statement ELSE statement
                   | SWITCH "(" expression ")" statement

iteration_statement: WHILE "(" expression ")" statement
                   | DO statement WHILE "(" expression ")" ";"
                   | FOR "(" expression_statement expression_statement ")" statement
                   | FOR "(" expression_statement expression_statement expression ")" statement

jump_statement: GOTO IDENTIFIER ";"
              | CONTINUE ";"
              | BREAK ";"
              | RETURN ";"
              | RETURN expression ";"

// Translation unit
translation_unit: external_declaration+

external_declaration: function_definition
                    | declaration

function_definition: declaration_specifiers declarator declaration_list compound_statement
                   | declaration_specifiers declarator compound_statement
                   | declarator declaration_list compound_statement
                   | declarator compound_statement

// Operators (multi-character)
PTR_OP: "->"
INC_OP: "++"
DEC_OP: "--"
LEFT_OP: "<<"
RIGHT_OP: ">>"
LE_OP: "<="
GE_OP: ">="
EQ_OP: "=="
NE_OP: "!="
AND_OP: "&&"
OR_OP: "||"
MUL_ASSIGN: "*="
DIV_ASSIGN: "/="
MOD_ASSIGN: "%="
ADD_ASSIGN: "+="
SUB_ASSIGN: "-="
LEFT_ASSIGN: "<<="
RIGHT_ASSIGN: ">>="
AND_ASSIGN: "&="
XOR_ASSIGN: "^="
OR_ASSIGN: "|="
ELLIPSIS: "..."

// Keywords
TYPEDEF: "typedef"
EXTERN: "extern"
STATIC: "static"
AUTO: "auto"
REGISTER: "register"
CHAR: "char"
SHORT: "short"
INT: "int"
LONG: "long"
SIGNED: "signed"
UNSIGNED: "unsigned"
FLOAT: "float"
DOUBLE: "double"
CONST: "const"
VOLATILE: "volatile"
VOID: "void"
STRUCT: "struct"
UNION: "union"
ENUM: "enum"
CASE: "case"
DEFAULT: "default"
IF: "if"
ELSE: "else"
SWITCH: "switch"
WHILE: "while"
DO: "do"
FOR: "for"
GOTO: "goto"
CONTINUE: "continue"
BREAK: "break"
RETURN: "return"
SIZEOF: "sizeof"

// Identifiers and constants
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
TYPE_NAME: /[A-Z][a-zA-Z0-9_]*/  // 简化处理，实际需要符号表

// Constants
CONSTANT: HEX_CONSTANT | OCT_CONSTANT | DEC_CONSTANT | CHAR_CONSTANT | FLOAT_CONSTANT
HEX_CONSTANT: /0[xX][0-9a-fA-F]+[uUlL]*/
OCT_CONSTANT: /0[0-7]+[uUlL]*/
DEC_CONSTANT: /[0-9]+[uUlL]*/
CHAR_CONSTANT: /L?'(\\.|[^\\'])'/
FLOAT_CONSTANT: /[0-9]+[Ee][+-]?[0-9]+[flFL]?/
              | /[0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?[flFL]?/
              | /[0-9]+\.[0-9]*([Ee][+-]?[0-9]+)?[flFL]?/

STRING_LITERAL: /L?"(\\.|[^\\"])*"/

// Comments and whitespace
COMMENT: /\/\*(.|\n)*?\*\//
LINE_COMMENT: /\/\/[^\n]*/

%import common.WS
%ignore WS
%ignore COMMENT
%ignore LINE_COMMENT