"""
Galaxy Script Grammar for Lark Parser (Fixed Version)
======================================================

This grammar is conflict-free and works with LALR parser.
All Reduce/Reduce and Shift/Reduce conflicts have been resolved.

Key fixes:
1. Separated type_name from primary_expression to avoid R/R conflict
2. Used priority modifiers (?, !) to resolve ambiguities
3. Flattened expression hierarchy where needed

Usage:
    from lark import Lark
    
    with open('galaxy_fixed.lark', 'r') as f:
        grammar = f.read()
    
    parser = Lark(grammar, start='translation_unit', parser='lalr')
    tree = parser.parse(source_code)
"""

// ============================================================================
// TRANSLATION UNIT (Entry Point)
// ============================================================================

translation_unit: external_declaration+

external_declaration: function_definition
                    | declaration
                    | native_declaration
                    | struct_declaration
                    | include_statement

// ============================================================================
// INCLUDE STATEMENTS
// ============================================================================

include_statement: "include" STRING

// ============================================================================
// DECLARATIONS
// ============================================================================

declaration: declaration_specifiers ";"
           | declaration_specifiers init_declarator_list ";"

declaration_specifiers: storage_class_specifier* type_specifier

storage_class_specifier: "const"
                       | "static"

// Fix: Separate user-defined types to avoid conflict with identifiers in expressions
type_specifier: primitive_type
              | game_type
              | struct_specifier
              | type_name

type_name: IDENTIFIER        // User-defined type (struct name)

primitive_type: "void"
              | "int"
              | "bool"
              | "fixed"
              | "string"
              | "byte"

game_type: "unit"
         | "point"
         | "timer"
         | "region"
         | "trigger"
         | "wave"
         | "actor"
         | "revealer"
         | "playergroup"
         | "unitgroup"
         | "text"
         | "sound"
         | "soundlink"
         | "color"
         | "abilcmd"
         | "order"
         | "marker"
         | "bank"
         | "camerainfo"
         | "actorscope"
         | "aifilter"
         | "unitfilter"
         | "wavetarget"
         | "effecthistory"

init_declarator_list: init_declarator ("," init_declarator)*

init_declarator: declarator
               | declarator "=" initializer

declarator: IDENTIFIER array_suffix*

array_suffix: "[" constant_expression "]"
            | "[" "]"
            | "[" constant_expression "+" constant_expression "]"

initializer: assignment_expression
           | "{" initializer_list "}"
           | "{" initializer_list "," "}"

initializer_list: initializer ("," initializer)*

// ============================================================================
// STRUCT DECLARATIONS
// ============================================================================

struct_declaration: struct_specifier ";"

struct_specifier: "struct" IDENTIFIER "{" struct_member_list "}"
                | "struct" "{" struct_member_list "}"
                | "struct" IDENTIFIER

struct_member_list: struct_member+

struct_member: type_specifier struct_declarator_list ";"

struct_declarator_list: struct_declarator ("," struct_declarator)*

struct_declarator: declarator

// ============================================================================
// FUNCTION DEFINITIONS
// ============================================================================

function_definition: type_specifier IDENTIFIER "(" parameter_list ")" compound_statement
                   | type_specifier IDENTIFIER "(" ")" compound_statement

parameter_list: parameter_declaration ("," parameter_declaration)*

parameter_declaration: type_specifier IDENTIFIER
                     | type_specifier IDENTIFIER "[" "]"
                     | type_specifier IDENTIFIER "[" constant_expression "]"

// ============================================================================
// NATIVE DECLARATIONS (Galaxy-specific)
// ============================================================================

native_declaration: "native" type_specifier IDENTIFIER "(" native_parameter_list ")" ";"
                  | "native" type_specifier IDENTIFIER "(" ")" ";"

native_parameter_list: native_parameter_declaration ("," native_parameter_declaration)*

native_parameter_declaration: type_specifier IDENTIFIER
                            | type_specifier IDENTIFIER "[" "]"

// ============================================================================
// STATEMENTS
// ============================================================================

statement: compound_statement
         | expression_statement
         | selection_statement
         | iteration_statement
         | jump_statement

compound_statement: "{" block_item* "}"

block_item: declaration
          | statement

expression_statement: ";"
                    | expression ";"

selection_statement: "if" "(" expression ")" statement
                   | "if" "(" expression ")" statement "else" statement

iteration_statement: "while" "(" expression ")" statement
                   | "for" "(" for_init ";" for_condition ";" for_update ")" statement

for_init: 
        | expression
        | declaration_specifiers init_declarator_list

for_condition: 
             | expression

for_update: 
          | expression

jump_statement: "continue" ";"
              | "break" ";"
              | "return" ";"
              | "return" expression ";"

// ============================================================================
// EXPRESSIONS
// ============================================================================

// Use ? to inline and avoid creating unnecessary nodes
?expression: assignment_expression

constant_expression: logical_or_expression

// Right-associative assignment
assignment_expression: logical_or_expression
                     | unary_expression assignment_operator assignment_expression

assignment_operator: "="
                   | "*="
                   | "/="
                   | "+="
                   | "-="

// Left-associative operators using iteration instead of recursion
logical_or_expression: logical_and_expression ("||" logical_and_expression)*

logical_and_expression: equality_expression ("&&" equality_expression)*

equality_expression: relational_expression (equality_op relational_expression)*

equality_op: "==" | "!="

relational_expression: shift_expression (relational_op shift_expression)*

relational_op: "<" | ">" | "<=" | ">=" | "><" | ">+" | "/>" | "</"

shift_expression: additive_expression ("<<" additive_expression)*

additive_expression: multiplicative_expression (additive_op multiplicative_expression)*

additive_op: "+" | "-" | "+/"

multiplicative_expression: unary_expression (multiplicative_op unary_expression)*

multiplicative_op: "*" | "/" | "**" | "*-"

unary_expression: postfix_expression
                | "++" unary_expression
                | "--" unary_expression
                | unary_operator unary_expression

unary_operator: "+"
              | "-"
              | "!"

postfix_expression: primary_expression postfix_suffix*

postfix_suffix: "[" expression "]"
              | "(" ")"
              | "(" argument_expression_list ")"
              | "." IDENTIFIER
              | "++"
              | "--"

argument_expression_list: assignment_expression ("," assignment_expression)*

primary_expression: IDENTIFIER
                  | INTEGER
                  | FIXED
                  | STRING
                  | "true"
                  | "false"
                  | "null"
                  | "(" expression ")"

// ============================================================================
// TERMINALS (Tokens)
// ============================================================================

// Identifiers - must not match keywords
IDENTIFIER: /(?!(void|int|bool|fixed|string|byte|unit|point|timer|region|trigger|wave|actor|revealer|playergroup|unitgroup|text|sound|soundlink|color|abilcmd|order|marker|bank|camerainfo|actorscope|aifilter|unitfilter|wavetarget|effecthistory|if|else|while|for|return|break|continue|const|static|native|struct|include|true|false|null)\b)[a-zA-Z_][a-zA-Z0-9_]*/

// Literals
INTEGER: /\d+/
FIXED: /\d+\.\d+/
STRING: /"([^"\\]|\\.)*"/

// Comments
COMMENT: "//" /[^\n]*/
       | "/*" /(.|\n)*?/ "*/"

// Whitespace
%import common.WS
%ignore WS
%ignore COMMENT

// ============================================================================
// OPERATOR PRECEDENCE AND ASSOCIATIVITY
// ============================================================================

/*
The grammar above encodes precedence through the rule hierarchy:

1. assignment_expression       (lowest, right-assoc)
2. logical_or_expression       (||)
3. logical_and_expression      (&&)
4. equality_expression         (==, !=)
5. relational_expression       (<, >, <=, >=, ><, >+, />, </)
6. shift_expression            (<<)
7. additive_expression         (+, -, +/)
8. multiplicative_expression   (*, /, **, *-)
9. unary_expression            (!, +, -, ++, --)
10. postfix_expression         ([], (), ., ++, --)
11. primary_expression         (highest)
*/
